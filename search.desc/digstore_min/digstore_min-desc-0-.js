searchState.loadedDescShard("digstore_min", 0, "Digstore Min - A simplified content-addressable storage …\nFormat version for compatibility\nProtocol version for URNs\nCurrent version of Digstore Min\nCommand-line interface for Digstore Min\nGlobal configuration management for Digstore Min\nCore types and utilities for Digstore Min\nCryptographic operations for zero-knowledge storage\nFile ignore system with .digignore support\nMerkle proof system for Digstore Min\nSecurity module for data scrambling and access control\nStorage layer for Digstore Min\nURN (Uniform Resource Name) system for Digstore Min\nAdd files to the repository\nAnalyze specific layer\nDisplay file contents from repository\nClear all staged files\nDigstore Min - Content-addressable storage system\nCreate a new commit\nGenerate shell completion scripts\nManage global configuration\nDecrypt encrypted content using URN\nShow differences between staged files and last commit\nGenerate merkle proof for content\nGenerate tamper-proof archive size proof\nRetrieve files from the repository\nShow root history analysis\nShow store information\nInitialize a new repository\nDeep layer inspection\nGenerate content key from URN and public key\nLayer management\nLayer management subcommands\nList staged files\nList all layers\nShow commit history\nProof system\nProof system subcommands\nShow current root information\nShow storage analytics\nStaging area management\nStaging area subcommands\nShow store statistics\nShow repository status\nStore management and information\nStore management subcommands\nVerify a merkle proof\nVerify archive size proof\nColor output: auto, always, never\nCLI command implementations\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInteractive CLI prompts for user input\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDisable progress bars\nSuppress non-error output\nPath to store directory\nEnable verbose output\nAuto-answer yes to all prompts\nAdd all files in the repository\nRetrieve at specific root hash\nShow at specific root hash\nSet author name\nDisplay specific byte range\nAverage chunk size in KB (default: 1024)\nOverride commit date\nShow what would be added\nOpen editor for message\nEdit configuration file in editor\nShow only encryption key\nForce add ignored files\nRead file list from stdin\nCreate full layer (not delta)\nOutput as JSON\nOutput as JSON\nOutput as JSON\nOutput as JSON\nOutput as JSON\nOutput as JSON\nOutput as JSON\nOutput as JSON\nConfiguration key to get/set\nList all configuration values\nCommit message\nInclude metadata in output\nRepository name\nDisable compression\nDon’t use pager for long output\nNumber all output lines\nOutput file (default: stdout)\nOutput file for decrypted data (default: stdout)\nOutput file for key information (default: stdout)\nPath or URN to retrieve\nInput file containing encrypted data\nFile path or URN\nFiles or directories to add\nMachine-readable output\nForce show progress even when piping\nAdd directories recursively\nShell to generate completion for\nShow short format\nDisplay chunk statistics\nShow global configuration file location\nShow only storage address\nUse specific store ID (default: generate random)\nUnset a configuration value\nURN to use for decryption (if not auto-detected)\nURN to generate key for\nConfiguration value to set\nVerify with merkle proof while retrieving\nShow chunk details\nShow chunk details\nShow chunk analysis\nShow file details\nShow file details\nShow layer header details\nOutput as JSON\nOutput as JSON\nOutput as JSON\nLayer hash to analyze\nLayer hash to inspect\nShow merkle tree information\nShow size information\nShow size information\nVerify layer integrity\nProve at specific root hash\nProve specific byte range\nGenerate compact proof\nExpected size in bytes\nOutput format: json, binary, text\nOutput format: compressed, json, binary\nRead proof from file instead of command line\nRead proof from stdin\nOutput as JSON\nOutput verification result as JSON\nWrite proof to file (default: stdout)\nOutput file (default: stdout)\nProof file to verify\nProof data (compressed hex string or file path with –…\nExpected root hash\nRoot hash (32-byte hex)\nShow compression statistics\nStore ID (32-byte hex) - optional, auto-detected from …\nStore ID (32-byte hex)\nTarget to prove\nExpected target hash\nShow detailed verification steps\nShow verbose proof generation steps\nShow detailed verification steps\nShow all files (no pagination)\nShow detailed information (file sizes, hashes)\nSpecific file to diff (default: all staged files)\nForce clear without confirmation\nOutput as JSON\nOutput as JSON\nOutput as JSON\nNumber of files to show per page\nShow only file names (no content diff)\nPage number (1-based)\nShow statistics summary\nNumber of context lines for content diff\nShow detailed breakdown\nShow configuration details\nShow detailed statistics\nShow deduplication metrics\nShow ASCII graph\nShow ASCII graph\nShow only the root hash\nOutput as JSON\nOutput as JSON\nOutput as JSON\nOutput as JSON\nOutput as JSON\nShow specific layer info\nShow per-layer analysis\nLimit number of entries\nLimit number of entries\nOne line per layer\nShow all paths\nShow performance metrics\nShow security metrics\nShow layers since date\nShow entries since date\nShow statistics\nShow detailed information\nAdd command implementation\nCommit command implementation\nConfiguration command implementation\nDecrypt command implementation\nCheck if we’re in a repository directory (has .digstore …\nGet command implementation\nInitialize command implementation\nKey generation command implementation\nLayer management commands\nLoad store ID from .digstore file\nProof system commands\nStaging area management commands\nStatus command implementation\nStore management and information commands\nExecute the add command\nRetrieve file at specific commit hash\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDisable pager (always output to stdout)\nShow line numbers\nFile path or URN to output\nExecute the commit command\nGenerate shell completion scripts\nEdit configuration file in editor\nExecute the config command\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOutput as JSON\nConfiguration key to get/set\nList all configuration values\nShow global configuration file location\nUnset a configuration value\nConfiguration value to set\nExecute the decrypt command\nExecute the get command\nExecute the init command\nExecute the keygen command\nShow chunk analysis\nExecute the inspect command\nReturns the argument unchanged.\nShow layer header details\nCalls <code>U::from(self)</code>.\nOutput as JSON\nLayer hash to inspect\nShow merkle tree information\nVerify layer integrity\nShow chunk details\nExecute the layers command\nShow file details\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOutput as JSON\nLayer hash to analyze (optional)\nList all layers\nShow size information\nGenerate archive size proof command (moved from …\nVerify archive size proof command (moved from …\nProve at specific commit hash\nProve specific byte range\nGenerate compact proof\nOutput format: json, binary, text\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOutput file for proof (default: stdout)\nTarget to prove (file path or URN)\nExecute the proof generate-archive-size command\nReturns the argument unchanged.\nRead proof from stdin\nCalls <code>U::from(self)</code>.\nProof file to verify\nExpected root hash\nExpected target hash\nShow detailed verification steps\nExecute the proof verify-archive-size command\nStage diff command - show differences between staged files …\nList staged files command\nFile has been deleted (in commit but not staged)\nFile change status for diff display\nInformation about a file difference\nFile has been modified\nFile is new (not in last commit)\nSummary statistics for stage diff\nFile is unchanged (same hash)\nExecute the stage diff command\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nArguments for the staged command\nClear all staged files\nExecute the staged command\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nExecute the status command\nExecute the history command\nReturns the argument unchanged.\nShow ASCII graph\nCalls <code>U::from(self)</code>.\nOutput as JSON\nLimit number of entries\nShow entries since date\nShow statistics\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOutput as JSON\nShow specific layer info\nReturns the argument unchanged.\nShow ASCII graph\nCalls <code>U::from(self)</code>.\nLimit number of entries\nOne line per layer\nShow layers since date\nExecute the root command\nReturns the argument unchanged.\nShow only the root hash\nCalls <code>U::from(self)</code>.\nOutput as JSON\nShow detailed information\nShow detailed breakdown\nShow deduplication metrics\nExecute the size command\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOutput as JSON\nShow per-layer analysis\nShow detailed statistics\nExecute the stats command\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOutput as JSON\nShow performance metrics\nShow security metrics\nShow configuration details\nExecute the store-info command\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOutput as JSON\nShow all paths\nAsk user for confirmation to overwrite existing .digstore …\nAsk user if they want to recreate a missing store\nHandle missing store scenario with interactive prompts\nInteractive store recreation workflow\nGlobal configuration management\nConfiguration key for setting values\nConfiguration value types\nCore Digstore configuration\nCrypto configuration\nGlobal configuration for Digstore\nUser-specific configuration\nDefault chunk size\nDefault compression\nCore configuration\nCrypto configuration\nCustom configuration values\nEditor for commit messages\nUser’s email for commits\nEnable encrypted storage (always true for zero-knowledge …\nPrompt user to configure if not set\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a configuration value\nGet author email with fallback\nGet author name with fallback\nGet the path to the global configuration file\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if user configuration is complete\nList all configuration values\nLoad global configuration from disk\nUser’s name for commits\nPublic key for URN transformation (hex encoded)\nSave global configuration to disk\nSet a configuration value\nUnset a configuration value\nUser configuration\n.digstore file management\nError types for Digstore Min\nHash utilities for Digstore Min\nCore data types for Digstore Min\nContents of a .digstore file\nWhen the link was created\nWhether encryption is enabled (always false for …\nReturns the argument unchanged.\nGet the store ID as a Hash\nCalls <code>U::from(self)</code>.\nCheck if this .digstore file is valid\nLast access time\nLoad .digstore file from disk\nCreate a new .digstore file configuration\nOptional repository name\nSave .digstore file to disk\nStore ID this project links to\nUpdate last accessed time\nFormat version\nChunk-related errors\nCompression errors\nConfiguration errors\nDecryption errors\nMain error type for Digstore operations\nEncryption errors\nContains the error value\nFile-related errors\nHex encoding/decoding errors\nGeneric error for unexpected conditions\nURN-related errors\nI/O errors\nLayer-related errors\nMerkle tree errors\nContains the success value\nProof-related errors\nResult type alias for Digstore operations\nSerialization errors\nStore-related errors\nTime parsing errors\nUUID errors\nCompression library errors\nCreate a new chunk not found error\nCreate a new decryption error\nCreate a new encryption error\nCreate a new file not found error\nReturns the argument unchanged.\nCreate a new internal error\nCalls <code>U::from(self)</code>.\nCreate a new invalid file path error\nCreate a new invalid layer format error\nCreate a new invalid store ID error\nCreate a new invalid URN error\nCreate a new layer not found error\nCreate a new proof generation failed error\nCreate a new store already exists error\nCreate a new store corrupted error\nCreate a new store not found error\nCreate a new URN parsing failed error\nCreate a streaming hasher for incremental hashing\nFinalize the hash and return the result\nReturns the argument unchanged.\nCompute SHA-256 hash of bytes (alias for sha256)\nCompute SHA-256 hash of multiple chunks of data\nCompute SHA-256 hash of a file\nCompute SHA-256 hash of two hashes (for merkle tree …\nCompute SHA-256 hash of a string\nCalls <code>U::from(self)</code>.\nCreate a new streaming hasher\nReset the hasher to initial state\nCompute SHA-256 hash of data\nUpdate the hash with new data\nA data chunk with its metadata\nChunk hash\nReference to a chunk within a file\nCommit information\nDelta layer containing only changes from parent\nFile entry in a layer\nFile metadata\nFull layer containing complete repository state\n32-byte SHA-256 hash\nHeader layer (Layer 0) containing metadata\nInternal node with left and right children\nLayer header information (256 bytes fixed size)\nLayer ID\nLayer metadata stored in JSON format\nLayer types\nLeaf node containing a hash\nMagic bytes for layer files\nRoot hash of a layer or repository\nSize of the header in bytes\nStore identifier (32-byte random value)\nTree node for merkle tree construction\nCurrent format version\nGet the underlying bytes\nAuthor information\nAuthor name\nList of chunks that make up this file\nNumber of chunks in this layer\nCompression algorithm used (0=None, 1=Zstd, 2=LZ4)\nThe actual chunk data\nOffset to data section\nSize of data section\nNumber of files\nNumber of files changed\nNumber of files in this layer\nFeature flags\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate from byte representation\nCreate a Hash from a 32-byte array\nCreate from bytes read from disk\nCreate a Hash from a hex string\nGeneration number\nGet the layer type\nGet the parent hash\nGet the hash of this node\nContent hash of the chunk\nHash of the complete file content\nHash of the chunk\nCommit hash (same as layer ID)\nOffset to index section\nSize of index section\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this file was deleted in this layer\nWhether this file was modified in this layer\nWhether this is a new file in this layer\nCheck if header is valid\nLayer identifier (hash of layer content)\nSequential layer number\nType of layer (0=Header, 1=Full, 2=Delta)\nLayer type\nMagic bytes for format identification: “DIGS”\nOffset to merkle tree section\nMerkle root of all files in this layer\nSize of merkle tree section\nCommit message (if any)\nCommit message\nFile metadata\nFile permissions (Unix-style)\nLast modified timestamp\nCreate a new layer header\nOffset within the original file\nOffset within the file\nParent commit hash\nParent layer root hash (zero for first layer)\nParent layer identifier\nFile path relative to repository root\nReserved bytes for future use (143 bytes to make total 256)\nSet the parent hash\nSize of the chunk in bytes\nTotal file size in bytes\nSize of the chunk\nTotal size of changes\nCreation timestamp (Unix timestamp)\nCreation timestamp\nCommit timestamp\nConvert to byte representation for binary format\nConvert to bytes for writing to disk\nConvert to hex string\nTotal size of all files\nFormat version (1)\nCreate a zero hash (for testing and special cases)\nDerive an encryption key from a URN\nDerive a storage address from transformed URN\nData encryption using URNs as keys\nURN transformation using public keys\nDecrypt data using a URN as the key source\nEncrypt data using a URN as the key source\nPublic key for URN transformation\nKey algorithm identifier\nThe public key bytes (32 bytes for Ed25519)\nReturns the argument unchanged.\nCreate from hex string\nCalls <code>U::from(self)</code>.\nCreate a new public key\nConvert to hex string\nTransform a URN using a public key\nRepository-wide ignore checking with hierarchical …\n.digignore file parser with exact .gitignore syntax …\nFile scanner with .digignore filtering and progress …\nRepository-wide ignore checker\nResult of ignore checking\nFile should be ignored\nFile should be included\nFile would be ignored but is explicitly included by …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCheck if any .digignore files exist\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a file should be ignored\nCreate a new ignore checker for a repository\nReload all .digignore files in the repository\nGet statistics about loaded parsers\nA compiled pattern from .digignore file\nParser for .digignore files\nNormal ignore pattern\nNegation pattern (starts with !)\nType of ignore pattern\nGet base directory\nWhether this pattern only matches directories\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a parser from .digignore content string\nCreate a new parser from a .digignore file\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether the pattern is anchored to a specific directory …\nCheck if a file path should be ignored\nThe original pattern string\nThe compiled glob pattern\nType of pattern (normal, negation, directory-only)\nGet all patterns (for debugging)\nScan completed\nDiscovering files in directories\nFile scanner with .digignore filtering and progress …\nApplying .digignore filters\nProcessing filtered files\nPhase of file scanning operation\nProgress information during scanning\nResult of file scanning operation\nStatistics from scanning operation\nCurrent file being processed (if any)\nDiscovery rate (files per second)\nElapsed time since scan started\nTotal files discovered so far\nFiles remaining after filtering\nFiles ignored by patterns\nFiles processed so far\nFiles that passed filtering\nFiltering efficiency (percentage ignored)\nSet whether to follow symbolic links\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFiles that were ignored and their reasons\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet maximum depth for directory traversal\nCreate a new filtered file scanner\nCurrent phase of scanning\nProcessing rate (files per second)\nProcessing rate (files per second)\nReload ignore rules\nScan multiple paths (for digstore add -A)\nScan a single directory with filtering\nFinal statistics\nTotal files discovered\nFiles that passed filtering\nFiles ignored by patterns\nTotal scanning time\nSet progress callback for real-time updates\nIncremental merkle tree updates for efficient layer …\nMerkle tree implementation using rs_merkle\nProof generation and verification\nArchive size proof generation and verification\nLocation of a chunk in the repository\nLocation of a file in the repository\nIncremental merkle tree builder that can efficiently add …\nIndex cache for fast file lookups\nIndex cache statistics\nLayer metadata for index\nEfficient layer writer with streaming\nAdd layer to index\nAdd a new leaf to the tree\nAdd multiple leaves efficiently\nClear cache\nFinalize the tree and return it\nFind chunk locations\nFind file location\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate proof for a leaf\nGet cache statistics\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet number of leaves\nGet the current root hash\nWrite layer using streaming to minimize memory usage\nA merkle proof for a specific leaf\nMerkle tree wrapper for Digstore Min\nCustom hasher implementation for rs_merkle\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBuild a merkle tree from a list of hashes\nGenerate a proof for a specific leaf index\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the number of leaves\nGet the leaf hash\nHash of the leaf being proved\nGet the leaf index\nIndex of the leaf being proved\nGet all leaf hashes\nSerialized proof bytes\nGet the root hash\nGet the root hash\nRoot hash this proof is against\nVerify this proof against a given root hash\nVerify a proof against this tree’s root\nProve a byte range\nProve a chunk exists\nProve a file exists\nProve a layer exists\nComplete merkle proof\nA single element in a merkle proof path\nProof generator for creating proofs from a store\nMetadata included with proofs\nPosition of a sibling in a merkle proof\nProof target specification\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserialize proof from JSON\nHash of the sibling node\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLayer number\nAdditional metadata\nCreate a new proof generator\nCreate a new proof for a byte range\nCreate a new proof for a file\nCreate a new proof for a layer\nWhether the sibling is on the left or right\nProof path elements\nType of proof\nGenerate a proof for a byte range\nGenerate a proof for a file\nGenerate a proof for a layer\nRoot hash to verify against\nStore ID\nTarget being proved\nTimestamp when proof was generated\nSerialize proof to JSON\nVerify this proof (uses the target hash from the proof …\nVerify proof independently with known data This function …\nVersion of the proof format\nTamper-proof archive size proof\nUltra-compact binary proof format for maximum compression\nIntegrity proofs to verify archive structure\nCompact proof element (33 bytes each)\nHash of archive header (64 bytes)\nTotal calculated size from layer index\nHash of first layer content (spot check)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from ArchiveSizeProof to compressed format\nCreate from compressed binary hex string\nDecode from compressed binary hex string\nGenerate tamper-proof size proof using archive’s …\nIntegrity proofs to prevent tampering\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHash of last layer content (spot check)\nHash of complete layer index\nMerkle tree root of layer sizes\nIndividual layer sizes from archive index\nPublisher’s public key (included by proof generator, …\nRoot hash (must exist in archive’s Layer 0)\nVerification that rootHash exists in Layer 0\nStore identifier (determines archive file)\nConvert back to ArchiveSizeProof format\nConvert to compressed binary hex string for maximum …\nEncode to maximum compression binary hex string\nNumber of layers verified in archive\nVerify archive size proof without file access\nVerify compressed hex proof directly\nURN-based access control system\nSecurity-specific error types\nData scrambling engine with URN-based key derivation\nAccess controller for URN validation\nAccess permission result\nAccess denied with reason\nAccess granted with validated URN\nExtension trait for Store to support access control\nCreate URN for newly created content\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet byte range with URN-based access control\nGet file with URN-based access control\nCheck if commit exists\nCheck if file exists at path in specific commit\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new access controller\nValidate URN for data access\nCheck if URN has required components for specific operation\nContains the error value\nContains the success value\nSecurity-specific error types\nResult type for security operations\nCreate access denied error\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate legacy format error\nCreate missing URN component error\nCreate scrambling failed error\nData scrambler with URN-based key derivation\nInternal scrambling state for stream cipher\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate scrambler from individual components\nCreate scrambler from URN\nGet the scrambling key (for debugging/testing)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new scrambling state with key\nGet current position\nProcess data at specific offset (for byte range access)\nProcess data with scrambling/unscrambling\nReset scrambler to initial state\nScramble data in-place\nSet position for byte range access\nUnscramble data in-place (same as scramble for XOR cipher)\nAdaptive processing system that automatically optimizes …\nBatch processing for efficient handling of many small files\nHigh-performance binary staging format for large …\nAdvanced storage optimizations including caching and …\nContent-defined chunking implementation using FastCDC\n.dig archive file format for storing multiple layers in a …\nEncrypted archive wrapper that transforms storage addresses\nLayer format implementation\nOptimized staging area for efficient bulk operations\nHigh-performance parallel file processing for large …\nSecure layer operations with URN-based data scrambling\nStore management for Digstore Min\nStreaming file processing that never loads entire files …\nResult of adaptive processing\nAdaptive processor that automatically chooses the best …\nMetrics for a single operation\nPerformance monitoring for adaptive tuning\nPerformance summary\nConfiguration for processing operations\nRecommended processing strategy\nWorkload analysis result\nWorkload analyzer\nType of workload detected\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nProcess files using adaptive strategy selection\nPerformance metrics for batch processing\nBatch processor for efficiently handling many small files\nResult of processing a batch of files\nInformation about a deduplicated chunk\nDeduplication statistics\nOptimized file scanner for large numbers of small files\nPerformance snapshot\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet current performance metrics\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nProcess many small files efficiently in parallel batches\nReset performance metrics\nScan directory in parallel for many small files\nBinary staged file data\nHigh-performance binary staging manager\nIndex entry for fast file lookups\nFixed-size header for the staging file\nStatistics about the staging area\nClear all staged files\nCompression type (0=none, 1=zstd)\nOffset to data section\nOffset to file data in the data section\nSize of data section in bytes\nSize of file data in bytes\nNumber of staged files\nFlags (reserved for future use)\nFlush any pending changes to disk\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet all staged files\nGet a staged file by path\nOffset to index section\nSize of index section in bytes\nInitialize an empty staging area\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a file is staged\nLoad existing staging area from disk\nMagic bytes: “DIGSTAGE”\nMemory-mapped staging file\nWritable memory map for updates\nCreate a new binary staging area\nHash of the file path for fast lookups\nLength of file path in bytes\nReload staging area from disk\nReserved for future use\nAdd a file to the staging area using streaming writes\nBatch add multiple files efficiently using proven …\nGet the number of staged files\nGet the staging file path\nGet staging file size and statistics\nFormat version\nMemory pool for buffer reuse\nBuffer pool statistics\nCache configuration\nCache statistics\nIntelligent chunk cache with LRU eviction\nMetadata about a cached chunk\nClear cache\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a buffer of appropriate size\nGet chunk from cache\nGet cache statistics\nGet pool statistics\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPut chunk in cache\nReturn buffer to pool for reuse\nChunking configuration\nContent-defined chunking engine using FastCDC\nAverage chunk size in bytes\nChunk data into content-defined chunks using FastCDC\nChunk a file by path\nChunk a file using streaming - never loads entire file …\nGet the configuration\nCreate chunks for a file entry\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nValidate configuration\nCreate configuration optimized for large files\nMaximum chunk size in bytes\nMinimum chunk size in bytes\nCreate a new chunking engine with default configuration\nCreate a new configuration with custom sizes\nReconstruct data from chunks\nCreate configuration optimized for small files\nVerify that chunks can reconstruct the original data\nCreate a new chunking engine with custom configuration\nArchive header (64 bytes)\nStatistics about the archive\n.dig archive manager\nLayer index entry (80 bytes)\nAdd a layer to the archive\nCRC32 checksum of layer data\nCompact the archive by removing gaps and optimizing layout\nCompression type (0=none, 1=zstd)\nCreate a new empty archive\nOffset to layer data section\nSize of data section in bytes\nFlush any pending changes to disk\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHelper function to get archive path for a store ID\nGet a layer by hash\nGet raw layer data by hash (for metadata layers like Layer …\nCheck if a layer exists in the archive\nLayer index for fast lookups\nOffset to layer index section\nSize of index section in bytes\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the number of layers in the archive\nNumber of layers in archive\nSHA-256 hash of layer (used as identifier)\nList all layers in the archive\nMagic bytes: “DIGARCH\\0”\nMigrate from old directory-based format\nMemory-mapped archive file (for reads)\nOffset to layer data in archive\nOpen existing archive\nGet archive file path\nReserved for future use\nReserved for future use\nSize of layer data in bytes\nGet archive statistics\nVerify archive integrity\nFormat version\nWrapper around DigArchive that handles address …\nAdd a layer with optional transformation\nFlush changes\nReturns the argument unchanged.\nGet a layer with optional transformation\nGet raw layer data with optional transformation\nCheck if layer exists with optional transformation\nCalls <code>U::from(self)</code>.\nCheck if transformation is enabled\nGet layer count\nList layers (returns original hashes, not transformed)\nCreate new encrypted archive wrapper\nGet the path of the archive file\nLayer structure with binary format support\nAdd a chunk to this layer\nAdd a file to this layer\nChunks in this layer\nGet the layer ID (computed from header + content)\nFile entries in this layer\nReturns the argument unchanged.\nLayer header (256 bytes)\nCalls <code>U::from(self)</code>.\nLayer metadata (JSON)\nCreate a new layer\nRead layer from file\nRead layer from disk (simplified JSON format for MVP) Read …\nSerialize layer to bytes\nVerify layer integrity\nWrite layer to disk in simplified JSON format (for MVP)\nBulk staging operation result\nCompact staging entry for memory efficiency\nStatistics about path interning\nOptimized staging area using IndexMap for ordered …\nEfficient file path interning to reduce memory usage\nA batch of staging operations for efficient persistence\nStatistics about the staging area\nAdd a single file (optimized for bulk additions)\nAdd multiple files in a single bulk operation\nClear all staged files\nCommit all staged files and clear staging\nCheck if a file is staged\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet all staged files (preserves insertion order)\nGet a staged file\nGet path string by ID\nGet staging statistics\nIntern a path string and return its ID\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRemove a file from staging\nGet statistics\nConfiguration for parallel processing\nHigh-performance parallel file processor\nProgress tracking for parallel operations\nResult of processing a single file\nStatistics from parallel processing\nWork item for parallel processing\nOptimized add-all operation with maximum parallelism\nBytes processed\nCurrent phase\nFiles discovered\nFiles ignored\nFiles processed\nFiles staged\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new parallel file processor\nProcess all files in a directory with maximum parallelism\nSimplified parallel processing without background threads\nBuffer size for file reading\nBatch size for staging writes\nStart time\nThreshold for using streaming vs batch processing\nWhether to use memory mapping for large files\nNumber of worker threads (0 = auto-detect)\nSecure layer wrapper that handles scrambling/unscrambling\nReturns the argument unchanged.\nGet byte range data with URN-based unscrambling\nGet specific file data with URN-based unscrambling\nCalls <code>U::from(self)</code>.\nThe underlying layer data\nCreate a new secure layer from a regular layer\nRead layer from .layer file with URN-based unscrambling\nScramble chunk data before storage\nWrite layer to .layer file with URN-based scrambling\nA file in the staging area\nMain store structure\nRepository status information\nAdd a directory recursively\nAdd a single file to staging (public method with …\nAdd files to staging\nAdd many files efficiently using batch processing\nArchive file for storing layers (with optional encryption)\nBatch processor for many small files\nChunking engine for processing files\nThe actual chunks\nClear all staged files\nCreate a commit from staged files (cumulative approach for …\nGet the current root hash\nCurrent root hash (latest generation)\nCurrent root hash\nFile entry with chunks\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a new random store ID\nGet byte range with URN-based access control and …\nGet the hash of a file in a specific commit (for change …\nGet a file by path from the latest commit\nGet a file at a specific root hash\nGet file with URN-based access control and unscrambling\nGet the global .dig directory\nGet the global path (archive directory) for backward …\nCheck if commit exists (uses archive format)\nCheck if file exists at path in specific commit\nCheck if a file has changed since the last commit\nInitialize a new store in the current directory\nInitialize a new store with options\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a file is staged\nWhether this file was added in this session\nLoad a layer by its ID using secure operations\nOpen an existing store from project directory\nOpen a store by ID directly (without project context)\nOpen an existing store with options\nGet the global store path Get the project path (if in …\nPath to the project directory (if in project context)\nList of staged files\nBinary staging area for files to be committed\nGet repository status\nGet the store ID\nStore identifier\nStore identifier\nStreaming chunking engine for large files\nTotal size of staged files\nRemove a file from staging Note: For binary staging, this …\nReference to a chunk without storing the actual data\nFile pointer that tracks position without loading data\nSimple rolling hash for content-defined chunking\nStreaming chunking engine that processes files without …\nStreaming file entry that only stores metadata, not data\nProcess a file using streaming - never loads entire file …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate file entry from streaming processing\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if at end of file\nGet current position in file\nRead data at specific offset without changing current …\nRead a chunk of data at current position\nReconstruct file data by reading only the necessary chunks\nReconstruct specific byte range without loading entire file\nGet total file size\nByte range specification\nParsed URN structure\nByte range specification\nEnd byte (inclusive, None means to end)\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a range from start to end of file\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a range for the last N bytes\nCreate a range from start to end (inclusive)\nParse a URN string\nURN parsing implementation\nResolve this URN to actual content using a store\nResource path within the store\nRoot hash (optional, defaults to latest)\nStart byte (inclusive, None means from beginning)\nStore identifier\nConvert URN back to string representation\nConvert to string representation (e.g., “#bytes=0-1023”…\nCreate a URN with a byte range\nParse byte range specification\nParse a URN string into a Urn struct Format: …")