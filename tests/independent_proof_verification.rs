//! Tests for independent proof verification
//!
//! These tests demonstrate that proofs generated by Digstore Min can be verified
//! independently without access to the original datastore, using only:
//! - The proof itself (JSON)
//! - The SHA256 hash of the data being verified
//! - The expected merkle root hash

use anyhow::Result;
use digstore_min::{Hash, Store};
use std::path::Path;
use tempfile::TempDir;

/// Test that demonstrates completely independent proof verification
#[test]
fn test_independent_proof_verification() -> Result<()> {
    // Setup: Create a test repository with multiple files to create a proper merkle tree
    let temp_dir = TempDir::new()?;
    let mut store = Store::init(temp_dir.path())?;

    // Create multiple test files to ensure we have a real merkle tree
    let test_content = b"Hello, this is test content for independent verification!";
    let test_file = temp_dir.path().join("test.txt");
    std::fs::write(&test_file, test_content)?;

    let other_content = b"Another file to create a merkle tree structure";
    let other_file = temp_dir.path().join("other.txt");
    std::fs::write(&other_file, other_content)?;

    // Add and commit both files
    store.add_file(Path::new("test.txt"))?;
    store.add_file(Path::new("other.txt"))?;
    let commit_hash = store.commit("Test commit for independent verification")?;

    // Generate a proof for the file
    let proof = digstore_min::proofs::Proof::new_file_proof(
        &store,
        Path::new("test.txt"),
        Some(commit_hash),
    )?;

    // Serialize the proof to JSON (this is what would be shared)
    let proof_json = proof.to_json()?;
    println!("Generated proof JSON:\n{}", proof_json);

    // INDEPENDENT VERIFICATION SIMULATION:
    // Imagine we're a completely separate system that only has:
    // 1. The proof JSON
    // 2. The actual data
    // 3. Knowledge of what the root hash should be

    // Step 1: Parse the proof from JSON
    let parsed_proof = digstore_min::proofs::Proof::from_json(&proof_json)?;

    // Step 2: Compute the SHA256 hash of our data
    let data_hash = digstore_min::core::hash::sha256(test_content);

    // Step 3: Get the expected root hash (in practice, this would come from a trusted source)
    let expected_root = proof.root; // In real scenario, this would be known independently

    // Step 4: Verify the proof INDEPENDENTLY (no datastore access needed!)
    let is_valid = parsed_proof.verify_independently(&data_hash, &expected_root)?;

    assert!(is_valid, "Proof should be independently verifiable");

    println!("✅ INDEPENDENT VERIFICATION SUCCESSFUL!");
    println!("  • Data hash: {}", data_hash.to_hex());
    println!("  • Root hash: {}", expected_root.to_hex());
    println!("  • Proof is cryptographically valid");

    Ok(())
}

/// Test independent verification with wrong data (should fail)
#[test]
fn test_independent_verification_with_wrong_data() -> Result<()> {
    // Setup: Create a test repository
    let temp_dir = TempDir::new()?;
    let mut store = Store::init(temp_dir.path())?;

    // Create test file
    let original_content = b"Original content";
    let test_file = temp_dir.path().join("test.txt");
    std::fs::write(&test_file, original_content)?;

    // Add and commit
    store.add_file(Path::new("test.txt"))?;
    let commit_hash = store.commit("Test commit")?;

    // Generate proof for original content
    let proof = digstore_min::proofs::Proof::new_file_proof(
        &store,
        Path::new("test.txt"),
        Some(commit_hash),
    )?;

    // Try to verify with different data (should fail)
    let wrong_content = b"Different content";
    let wrong_data_hash = digstore_min::core::hash::sha256(wrong_content);
    let expected_root = proof.root;

    let is_valid = proof.verify_independently(&wrong_data_hash, &expected_root)?;

    assert!(!is_valid, "Proof should fail with wrong data");

    println!("✅ TAMPER DETECTION SUCCESSFUL!");
    println!("  • Proof correctly rejected tampered data");

    Ok(())
}

/// Test independent verification with byte range
#[test]
fn test_independent_byte_range_verification() -> Result<()> {
    // Setup
    let temp_dir = TempDir::new()?;
    let mut store = Store::init(temp_dir.path())?;

    // Create test files with known content (multiple files for proper merkle tree)
    let full_content = b"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let test_file = temp_dir.path().join("test.txt");
    std::fs::write(&test_file, full_content)?;

    let other_content = b"Another file for merkle tree";
    let other_file = temp_dir.path().join("other.txt");
    std::fs::write(&other_file, other_content)?;

    // Add and commit both files
    store.add_file(Path::new("test.txt"))?;
    store.add_file(Path::new("other.txt"))?;
    let commit_hash = store.commit("Test commit")?;

    // Generate proof for byte range (bytes 10-19: "ABCDEFGHIJ")
    let proof = digstore_min::proofs::Proof::new_byte_range_proof(
        &store,
        Path::new("test.txt"),
        10,
        19,
        Some(commit_hash),
    )?;

    // Independent verification
    let range_content = &full_content[10..=19]; // "ABCDEFGHIJ"
    let range_hash = digstore_min::core::hash::sha256(range_content);
    let expected_root = proof.root;

    let is_valid = proof.verify_independently(&range_hash, &expected_root)?;

    assert!(
        is_valid,
        "Byte range proof should be independently verifiable"
    );

    println!("✅ BYTE RANGE VERIFICATION SUCCESSFUL!");
    println!(
        "  • Range content: {:?}",
        std::str::from_utf8(range_content)?
    );
    println!("  • Range hash: {}", range_hash.to_hex());

    Ok(())
}

/// Demonstrate that proofs contain all necessary information for verification
#[test]
fn test_proof_self_containment() -> Result<()> {
    // Setup
    let temp_dir = TempDir::new()?;
    let mut store = Store::init(temp_dir.path())?;

    let test_content = b"Self-contained proof test";
    let test_file = temp_dir.path().join("test.txt");
    std::fs::write(&test_file, test_content)?;

    store.add_file(Path::new("test.txt"))?;
    let commit_hash = store.commit("Test commit")?;

    // Generate proof
    let proof = digstore_min::proofs::Proof::new_file_proof(
        &store,
        Path::new("test.txt"),
        Some(commit_hash),
    )?;

    // Verify that the proof contains all necessary information
    match &proof.target {
        digstore_min::proofs::ProofTarget::File {
            file_hash,
            path,
            at,
        } => {
            println!("✅ PROOF CONTAINS:");
            println!("  • File path: {}", path.display());
            println!("  • File hash: {}", file_hash.to_hex());
            println!("  • Root hash: {}", proof.root.to_hex());
            println!("  • Commit hash: {}", at.unwrap().to_hex());
            println!(
                "  • Proof elements: {} sibling hashes",
                proof.proof_path.len()
            );

            // Verify the file hash matches our content
            let computed_hash = digstore_min::core::hash::sha256(test_content);
            assert_eq!(
                *file_hash, computed_hash,
                "Proof contains correct file hash"
            );
        },
        _ => panic!("Expected file proof"),
    }

    println!("✅ PROOF IS COMPLETELY SELF-CONTAINED!");

    Ok(())
}
